\section{Introduction}

We all rely on messaging applications like WhatsApp, Facebook Messenger, Signal, etc.\ in our daily lives and take it for granted that our messages will be transmitted securely, for some definition of ``secure''. A common security feature expected from the protocol employed in a messaging application is end-to-end encryption, i.e.\ that only the end users of a messaging session can read the messages being sent and the service provider or any party with access to the communication channel learns nothing of their contents. The protocol should work in an asynchronous setting: we would like to send messages even when the recipient is offline, and we expect them to receive the message once they come online. For this, we must rely on a delivery service to store and deliver the messages. Of course, also this delivery service should learn nothing from the messages.

There are two more advanced security features expected from messaging protocols today, both related to security in case a user is compromised:
\begin{itemize}
	\item forward secrecy (FS): the compromise should not reveal the contents of old messages
	\item post-compromise security (PCS): after the user recovers from the compromise, new messages are secure once again
\end{itemize}
As a user may well not know that they have been compromised, ensuring PCS requires regularly updating the key material used for encryption (in a way that the information leaked in a compromise \emph{before} the update does not suffice to compute encryption keys used \emph{after} the update). The more often the key material is updated, the stronger the level of PCS that is achieved. Thus, updating the key material should be an efficient operation.

For messaging between two users, the Double Ratchet protocol \cite{double-ratchet}, the main component of the Signal Protocol, is a widely adopted solution used by major messaging applications such as Signal, WhatsApp, Facebook Messenger and more. It is well-studied and achieves all of the above security guarantees \cite{double-ratchet-analysis}. For messaging in a group of more than two users, a straightforward solution is to maintain 1:1 communication channels using the Double Ratchet protocol between every pair of users and send messages to the group by sending them to every member individually. This achieves very strong security guarantees but requires a number of encryption operations linear in the group size to send a message.

Another common solution is to use sender keys \cite{sender-keys}: every user creates a symmetric key, their \emph{sender key}, and distributes this sender key to every other user using 1:1 channels as before. A user sending a message then derives a symmetric encryption key for the message from their sender key, while continually updating their sender key (with each sent message) to provide FS. However, achieving PCS is costly: if a user is compromised, the sender keys of all users are leaked and recovering from the compromise requires each user to send a new sender key to every other user over the respective 1:1 channels, resulting in a number of operations linear in the group size per user and a quadratic number of operations in total. Moreover, dynamic group membership introduces additional complexity:
\begin{itemize}
	\item adding a new member involves the new member sharing their sender key with all other group members
	\item removing a member requires distributing new sender keys in the group, just like recovering from a compromise
\end{itemize}
The Messaging Layer Security (MLS) protocol, recently standardized in \cite{rfc9420}, proposes a solution for group messaging with better efficiency and the same strong security guarantees as for the two-party case. Updating key material and adding or removing members can be achieved with a logarithmic number of operations (although the complexity may still degrade to linear in certain scenarios). At the core of MLS is a fairly recent primitive called a \emph{continuous group key agreement} (CGKA) scheme \cite{rtreekem} (this primitive was introduced only \emph{after} the first draft of the MLS protocol). In essence, a CGKA scheme enables a group of users to agree on a \emph{group key}, which they can then use to derive symmetric message encryption keys. This key must be indistinguishable from a random key for anyone outside the group eavesdropping on all communication. However, a CGKA scheme must also achieve FS and PCS, and support dynamic group membership. Hence, it must provide mechanisms for members to update their key material, add new users to the group and remove members from the group. Moreover, the scheme must work in the asynchronous setting with an untrusted service to deliver protocol messages.

The CGKA scheme used in the MLS protocol is called TreeKEM (initially proposed in \cite{treekem}) and the majority of the literature on MLS is dedicated to analyzing TreeKEM or proposing better CGKA schemes. We refer the reader to \cite[Section 1.3]{guillermo-thesis} for an in-depth overview of the literature. The TreeKEM protocol has undergone multiple changes since its inception. In this work, we refer to the version documented in RFC 9420. Given that the vision for the MLS protocol is for it to become the new standard for messaging protocols and that it has support from several large companies \cite{google-mls,mls-support}, it has the potential to be used by a huge number of users. Thus, understanding the security of MLS and hence also of TreeKEM is of great importance. This means having formal security guarantees about the security provided by TreeKEM (based on appropriate hardness assumptions).

\subsection{The TreeKEM protocol} \label{sec:treekem-overview}

\paragraph{Propose and commit syntax}

As a CGKA scheme, TreeKEM must support operations for updating the key material of a group member, adding a new user and removing a member. The syntax for these operations has changed over time. In the current version of MLS, the protocol uses so-called \emph{proposals} and \emph{commits}. Whenever a user would like to have their key material updated, add a new user or remove a group member, they create a corresponding \emph{update}, \emph{add} or \emph{remove proposal}, respectively, and share this proposal with the group. Any group member can then create a \emph{commit} to apply a set of proposals, create a new group key and update their key material in the process. The commit object includes (encrypted) information such that every group member can update their view of the group and compute the new group key.

\paragraph{TreeKEM dynamics}

TreeKEM uses a full binary tree to model the group and every user is associated with a leaf in the tree (the remaining leaves may be left empty). Each user maintains a synchronized view of the tree, though different users will know more about different parts of the tree. The group key is derived from the root of the tree. Every node $n$ in the tree has an associated key pair $(pk_n, sk_n)$ output by $\Pi.\gen$ where $\Pi$ is a public-key encryption scheme. All public keys are known to all users. Let the \emph{direct path} of a leaf be the path from the leaf's parent to the root. A leaf's \emph{path to the root} refers to the same path but including the leaf as well. Every user at a leaf knows the secret key of their leaf and, in the usual case, the secret keys of all nodes on their direct path, though there can be exceptions to this rule. To illustrate the scheme and how commit operations are performed, we will consider a group with users $A, B, \ldots, G$ and $H$, as depicted in Figure~\ref{fig:treekem-tree}. In the following, we will use these labels for the users both to refer to the users themselves and to their nodes in the tree.

\begin{figure}
	\begin{center}
		\includegraphics{figures/treekem-tree}
	\end{center}
	\caption{Illustration of a group with users 8 users in the TreeKEM protocol.}\label{fig:treekem-tree}
\end{figure}

\paragraph{Simple commits} \label{sec:simple-commit} The idea behind this tree structure is that it allows for a user creating a commit with a new group key to share the new group key with the group using only a few encryptions, while still updating all the secrets the user knew in the tree in order to recover from a possible compromise (recall that in a CGKA scheme a commit also updates the committer's key material).
To illustrate how a commit is performed and how the new group key is computed, say user $A$ performs a commit. Let us consider commits without any proposals. TreeKEM specifies two hash functions $\hgen, \hdep \colon \{0, 1\}^{\rho(\eta)} \to \{0, 1\}^{\rho(\eta)}$ where $\rho(\eta)$ gives the number of random bits used by $\Pi.\gen(1^\eta)$. The depth of user $A$ is $d = 3$. $A$ will replace all the $d + 1$ nodes on their path to the root with new nodes $A, p_1, \ldots, p_d$. (In practice $A$ would just replace the information stored in the original nodes.)
The key pairs for the new nodes are sampled as follows. For the leaf node $A$, user $A$ simply samples a key pair by running $\Pi.\gen(1^\eta)$. For the remaining nodes, they first sample $s_1 \from \{0, 1\}^{\rho(\eta)}$ and compute the key pair of the first parent $p_1$ as $\Pi.\gen(1^\eta, \hgen(s_1))$. For $i \in \{2, \ldots, d\}$ they then compute $s_i \coloneqq \hdep(s_{i - 1})$ and set the key pair of $p_i$ to be $\Pi.\gen(1^\eta, \hgen(s_i))$. The new group key is $k \coloneqq \hdep(s_{d})$.

User $A$ only needs to share (encryptions of) the seeds $s_i$ for the other users to update their view of the tree and compute the new group key:
\begin{itemize}
	\item To share the group key with user $B$, $A$ computes the ciphertext $c_1 \from \Pi.\enc_{pk_B}(s_1)$. $B$ can then compute the seed $s_1$, then use that to compute the seeds $s_2, \ldots, s_d$, the key pairs of all new nodes on their path to the root and the group key $k$.
	\item To share the new group key with users $C$ and $D$, $A$ computes the ciphertext $c_2 \from \Pi.\enc_{pk_X}(s_2)$, where $X$ is the parent of the nodes $C$ and $D$. Both $C$ and $D$ know the secret key $sk_X$ of their parent and can decrypt $c_2$.
	\item To share the new group key with users $E, F, G$ and $H$, $A$ computes the ciphertext $c_3 \from \Pi.\enc_{pk_Y}(s_3)$, where $Y$ is the right child of the root node. Again, all users under $Y$ know $sk_Y$ and can thus decrypt $c_3$.
\end{itemize}
The commit $c$ that $A$ shares with all users includes the ciphertexts $c_1, c_2$ and $c_3$ and the public keys of all new nodes. Figure~\ref{fig:treekem-simple-update} illustrates the commit performed by $A$.

\begin{figure}
	\begin{center}
		\includegraphics{figures/treekem-simple-update}
	\end{center}
	\caption{The commit by user $A$ described in the text. Dashed directed edges illustrate the fact that the target is related to the source via the hash function $\hdep$. The solid directed edges illustrate the fact that the seed of the target node is encrypted to the public key of the source node.}\label{fig:treekem-simple-update}
\end{figure}

The nodes $B, X$ and $Y$ form the \emph{copath} of $A$: the copath of a node $v$ consists of the sibling of each node on $v$'s path to the root, excluding the root itself. In the ideal case as above, a node performing a commit only has to compute one encryption for each node on its copath, i.e. logarithmically many encryptions in the total number of users.


The above concepts suffice to understand our main results. For a discussion of how proposals are incorporated into a commit, we refer the reader to Section~\ref{sec:treekem-overview-proposals} of the appendix.

\subsection{The GSD game} \label{sec:gsd-intro}

The Generalized Selective Decryption (GSD) security game \cite{gsd} was introduced precisely to analyze adaptive security for protocols based on a graph-like structure, as is the case with TreeKEM. It was initially defined for the private-key setting and later adapted to the public-key setting in \cite{ttkem}.

In the GSD security game, given an encryption scheme a graph, the \emph{GSD graph}, is constructed by the challenger where every node in the graph is associated with a symmetric key in the private-key setting, or a public/private key pair in the public-key setting. The adversary can then request encryptions of a node's (secret) key under the (public) key of another node. In the public-key setting, such an \emph{encryption query} also reveals the latter node's public key. This creates an \emph{encryption edge} in the graph, directed from the node whose (public) key was used for encryption to the node whose key was encrypted. The adversary can also corrupt any node, which reveals its (secret) key and allows the adversary to compute the (secret) key of any other node reachable from the corrupted node in the graph by performing decryptions along the path to the other node. At the end of the game the adversary chooses a node to be challenged on, the \emph{challenge node}. A coin is then tossed and the adversary is given either the (secret) key of the challenge node or a uniformly random (secret) key and it must guess which scenario it is in. The possible choices for the challenge node must of course be restricted to nodes whose keys were not compromised through a corruption, meaning that the challenge node should never be reachable from a corrupted node in the graph. Further restrictions are also necessary which we do not go into here and refer the reader to Section~\ref{sec:sd-gsd-game}. Figure~\ref{fig:gsd-example} illustrates what an example GSD graph may look like.

\begin{figure}
	\begin{center}
		\includegraphics{figures/gsd-example}
	\end{center}
	\caption{An illustration of the GSD graph for an instance of the GSD game. The challenge node is $v$. The node $c$ was corrupted, resulting in all nodes reachable from it being compromised, as marked with red color.} \label{fig:gsd-example}
\end{figure}

The graph constructed in the public-key GSD game and the tree structure behind the TreeKEM protocol clearly resemble each other. Let $\Pi$ the public-key encryption scheme in use, where $\Pi.\gen(1^\eta)$ samples $\rho(\eta)$ random bits. We can make some small modifications to the public-key GSD game such that the operations performed in TreeKEM match the ones performed in this modified GSD game. Take the functions $\hgen, \hdep$ used in TreeKEM and first modify the game as follows:
\begin{itemize}
	\item the key pair of a node $v$ is generated by sampling a seed $s_v \in \{0, 1\}^{\rho(\eta)}$ and computing $(pk_v, sk_v) = \Pi.\gen(1^\eta, \hgen(s_v))$
	\item encryption queries encrypt the seed of the target node instead of its secret key
\end{itemize}
Now the generation of key pairs and the encryptions computed in TreeKEM match what is done in this adapted GSD game. To model the fact that in TreeKEM the seed of a node may depend on the seed of another node through $\hdep$ (as in the new direct path computed in a commit), we can introduce a new type of edge which we call a \emph{seed dependency}: a seed dependency $(u, v)$ implies that $s_v = \hdep(s_u)$.

\subsection{Existing security proofs}

The work in \cite{ttkem} made use of the relationship between the (public-key) GSD game and TreeKEM described in the previous section. They proved a polynomial bound for the adaptive security of the public-key GSD game in the Random Oracle Model (ROM) \cite{rom} for an arbitrary IND-CPA secure public-key encryption scheme. The core idea behind their proof is simple. Intuitively, the only way for an adversary to learn about the seed of an uncorrupted node for the first time is through the encryption edges into the node. The authors show that in the ROM, one can reduce security in the GSD game to the IND-CPA security of the public-key encryption scheme with a moderate security loss. They apply standard guessing arguments and a clever, albeit complicated, hybrid argument to achieve a security loss in $\mathcal{O}(N^2)$, where $N$ is the number of nodes in the GSD graph. The $N^2$ loss stems from the fact that two nodes in the GSD graph need to be guessed correctly for the reduction to succeed.

This result implies a polynomial bound for the security of TreeKEM as a CGKA scheme as outlined in \cite[Theorem 4]{ttkem} and subsequently proven in more detail in \cite[Theorem 12]{modular-group-messaging}, and was the first proof of adaptive security for TreeKEM. As far as we know, this is the tightest result on the security of TreeKEM in the literature.

\subsection{Security model}

We prove adaptive CGKA security of TreeKEM for a single group and a single challenge query when the DHIES scheme is used. Additionally, our result easily extends to adversaries performing multiple challenge queries with the same security loss (irrespective of the number of challenges). Our security definition is very close to the definition provided in \cite[Section 4.1.2]{modular-group-messaging}, but gives the adversary less power. We provide a weaker definition in order to simplify the definition and proof. However, we are confident that the exact same result can be proven for the CGKA security definition in \cite{modular-group-messaging}. The additional power given to the adversary in \cite{modular-group-messaging} should only affect the set of commits that the adversary can ask to be challenged on in the CGKA security game (defined in Section~\ref{sec:cgka} of the appendix).

\subsection{Contributions}

\paragraph{Tighter GSD security for DHIES} In this work, we formally prove the adaptive security of a specific public-key encryption scheme, the DHIES  scheme \cite{dhies}, in the adapted public-key GSD game described above, in the ROM. Focusing on the DHIES scheme allows us to achieve a tighter bound than the one in \cite{ttkem}. Each encryption of a seed $s_v$ with DHIES is a tuple of the form $\langle g^{x}, c \rangle$ with $c \from \Pi_s.\enc_{k}(s_v)$, where $k = \hdh(g^{x y})$, $g$ is a generator in the Diffie-Hellman group, $\Pi_s$ is the private-key encryption scheme used in DHIES, $\hdh$ is a hash function and $y$ is the secret key of the source node of the encryption edge. By modelling $\hdh$ as a random oracle, we know that in order for an adversary to learn anything from this encryption, intuitively, they must have either learned $k$ by querying $\hdh$ and then decrypting the ciphertext $c$, or they must have gleaned information from $c$ without knowing the key $k$. We can reduce the first case to the hardness of the Diffie-Hellman problem with a security loss in $\mathcal{O}(N)$. To achieve a linear loss, we first guess the node $v$ for which the Diffie-Hellman problem was solved on an outgoing encryption edge and exploit the self-reducibility property of the Diffie-Hellman problem in order to embed a single Diffie-Hellman challenge into all outgoing edges. The second case can be reduced to the security of the private-key encryption scheme with a security loss in $\mathcal{O}(\delta \cdot N)$ where $\delta$ is the maximum in-degree in the GSD graph.
This follows from guessing the target node $s_v$ and then applying a standard hybrid argument to the up to $\delta$ encryption edges ending in $v$.\footnote{The same hybrid argument does not work for directly reducing to the security of the public-key encryption scheme due to a technicality.} In Section~\ref{sec:tighter-mis-eav-security} of the appendix we show that the security loss can be reduced to $\mathcal{O}(N)$ for a very specific set of schemes.

Besides providing a tighter bound, our proof has further significant advantages. Arguably, it is more intuitive and less complex than the ones in \cite{modular-group-messaging,ttkem}. Furthermore, our approach can easily be adapted to prove the same security loss in a GSD game with multiple challenge queries. Both of these advantages stem from how we compute the challenge in our GSD definition. See Section~\ref{sec:sd-gsd-game} for details.

\paragraph{The security of TreeKEM} Our final result for TreeKEM has a security loss in $\mathcal{O}(u \cdot (c \cdot \log(u) + p))$ reducing to EAV security\footnote{EAV security is implied by IND-CPA security. See Section~\ref{sec:security-definitions} of the appendix for details.} of the private-key encryption scheme  and a loss in $\mathcal{O}(c \cdot \log(u) + p)$ reducing to the hardness of the Diffie-Hellman problem, where $c$ is the number of commits, $p$ the number of add or update proposals and $u$ the number of users. As with GSD, our result holds irrespective of the number of challenge queries. The result in \cite{ttkem} implies a security loss of $\mathcal{O}((c \cdot \log(u) + p)^2)$ for a single challenge query, reducing to IND-CPA security of the public-key encryption scheme. This can be generalized to multiple challenges by a hybrid argument, involving an additional multiplicative loss in the number of challenges.
When $p$ is small such that $p \le c \cdot \log(u)$, the losses simplify to $\mathcal{O}(c \cdot u \cdot \log(u))$ and $\mathcal{O}(c \cdot \log(u))$, respectively, as opposed to $\mathcal{O}((c \cdot \log(u))^2)$ in \cite{ttkem}. In this setting, our result guarantees 90 bits of security with 128-bit parameters and 210 bits with 256-bit parameters for large groups (under standard assumptions).
When $p$ is large, e.g. when many updates are applied in each commit, the losses simplify to $\mathcal{O}(c \cdot u^2)$ and $\mathcal{O}(c \cdot u)$ as opposed to $\mathcal{O}((c \cdot u)^2)$ in \cite{ttkem}. Our result guarantees 95 bits of security when a 128-bit Diffie-Hellman group is combined with 256-bit AES, while the result in \cite{ttkem} only guarantees 64 bits. Using 256-bit parameters gives a 209-bit security level.

\subsection{Relation to MLS security}
The work in \cite{modular-group-messaging} provides a comprehensive security definition for group messaging protocols and reduces the security of MLS to the security of its underlying primitives, including the CGKA scheme. Since our proof can be adapted to go through with the CGKA definition used in this work, our result implies a tighter result for the security of MLS as a whole. However, the security proof of MLS in \cite{modular-group-messaging} has a very large (but polynomial) loss and even with our improved bound for TreeKEM we don't expect this to provide a meaningful level of security. Therefore, finding a tighter reduction for the MLS protocol as a whole is a crucial open problem on the path to proving meaningful security guarantees for the protocol.
