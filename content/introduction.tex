\section{Introduction}

We all rely on messaging applications like WhatsApp, Facebook Messenger, Signal, etc.\ in our daily lives and take it for granted that our messages will be transmitted securely, for some definition of ``secure''. A common security feature expected from the protocol employed in a messaging application and known also to the general public is end-to-end encryption, i.e.\ that only the end users of a messaging session can read the messages being sent and the service provider or any party with access to the communication channel learns nothing of their contents. Another straightforward feature is that the protocol should work in an asynchronous setting: we would like to send messages even when the recipient is offline, and we expect them to receive the messsage once they come online. For this we must rely on a delivery service to store and deliver the messages. Of course also this delivery service should learn nothing about the contents of the messages.

There are two more advanced security features expected from messaging protocols today, both related to security in case a user is compromised:
\begin{itemize}
	\item forward secrecy (FS): the compromise should not reveal the contents of old messages
	\item post-compromise security (PCS): after the user recovers from the compromise, new messages are secure once again
\end{itemize}
As a user may well not know that they have been compromised, ensuring PCS requires regularly updating the key material used for encryption (in a way that the information leaked in a compromise \emph{before} the update does not suffice to compute encryption keys used \emph{after} the update). The more often the key material is updated, the stronger the level of PCS that is achieved. Thus, updating the key material should be an efficient operation.

For messaging between two users, the Double Ratchet protocol \cite{double-ratchet}, the main component of the so-called Signal Protocol, is a widely adopted solution used by major messaging applications such as Signal, WhatsApp, Facebook Messenger and more. It is well studied and achieves all of the above security guarantees \cite{double-ratchet-analysis}. For messaging in a group of more than two users, a straightforward solution is to maintain 1:1 communication channels using the Double Ratchet protocol between every pair of users and send messages to the group by sending them to every member individually. This achieves very strong security guarantees, but requires a number of encryption operations linear in the group size to send a message.

Another common solution is to use sender keys \cite{sender-keys}: every user creates a symmetric key, their \emph{sender key}, and distributes this sender key to every other user using 1:1 channels as before. A user sending a message then derives a symmetric encryption key for the message from their sender key, while continually updating their sender key (with each sent message) to provide FS. However, achieving PCS is costly: if a user is compromised, the sender keys of all users are leaked and recovering from the compromise requires each user to send a new sender key to every other user over the respective 1:1 channels, resulting in a number of operations linear in the group size per user and a quadratic number of operations in total. Moreover, dynamic group membership introduces additional complexity:
\begin{itemize}
	\item adding a new member involves the new member sharing their sender key with all other group members
	\item removing a member requires distributing new sender keys in the group, just like recovering from a compromise
\end{itemize}
The Messaging Layer Security (MLS) protocol, recently standardized in \cite{rfc9420}, proposes a solution for group messaging with better efficiency and the same strong security guarantees as for the two-party case. Updating key material and adding or removing members can be achieved with a logarithmic number of operations (although the complexity may still degrade to linear in certain scenarios). At the core of MLS is a fairly recent primitive called a \emph{continuous group key agreement} (CGKA) scheme \cite{rtreekem} (this primitive was introduced only \emph{after} the first draft of the MLS protocol). In essence, a CGKA scheme enables a group of users to agree on a \emph{group key}, which they can then use to derive symmetric message encryption keys. This key must be indistinguishable from a random key for anyone outside the group eavesdropping on all communication. However, a CGKA scheme must also achieve FS and PCS, and support dynamic group membership. Hence, it must provide mechanisms for members to update their key material, add new users to the group and remove members from the group. Moreover, the scheme must work in the asynchronous setting with an untrusted service to deliver protocol messages.

The CGKA scheme used in the MLS protocol is called TreeKEM (initially proposed in \cite{treekem}) and the majority of the literature on MLS is dedicated to analyzing TreeKEM or proposing better CGKA schemes as in \cite{ttkem,rtreekem,insider-security,modular-group-messaging}. The TreeKEM protocol has undergone multiple changes since its inception. In this work we refer to the version documented in RFC 9420.

Given that the vision for the MLS protocol is for it to become the new standard for messaging protocols and that it has support from several large companies \cite{google-mls,mls-support}, it has the potential to be used by a huge number of users. Thus, understanding the security of MLS and hence also of TreeKEM is of great importance. This means having formal security guarantees about the security provided by TreeKEM (based on appropriate hardness assumptions). The first important step in this direction was the conception of the CGKA primitive and the accompanying definitions of security introduced in different works (for example \cite{rtreekem,ttkem}). Such definitions clarify what kind of adversaries we can provide security against and thus what kind of security one should expect from the scheme when using it in practice. Moreover, proofs of (reasonably tight) security under these definitions show what level of security we should expect from the scheme and serve as a guide to implementors on what values to choose for the security parameter. Proofs also provide strong justification that there are no flaws in the overall design of the scheme.

One choice that can be made when defining the security of a CGKA scheme is whether the adversary is modeled as \emph{selective} or \emph{adaptive}. In the former case, the adversary must provide all the interactions it will have with the protocol and when it will attempt to break the scheme at the beginning of the security game, while in the latter case the adversary can make its decisions based on responses from previous interactions. Clearly, the adaptive setting is much closer to how an attack would unfold in practice, so it is desirable to prove security against adaptive adversaries. However, achieving this without too much of a blow-up in the security loss is a challenge since one often resorts to guessing actions performed by the adversary.

\subsection{The TreeKEM protocol} \label{sec:treekem-overview}

\paragraph{Propose and commit syntax}

As a CGKA scheme, TreeKEM must support operations for updating the key material of a group member, adding a new user and removing a member. The syntax for these operations has changed over time. In the current version of MLS, the protocol uses so-called \emph{proposals} and \emph{commits}. Whenever a user would like have their key material updated (by someone else), add a new user or remove a group member, they create a corresponding \emph{update}, \emph{add} or \emph{remove proposal}, respectively, and share this proposal with the group. Any group member can then create a \emph{commit} to apply a set of proposals, create a new group key and update their key material in the process. The commit object includes (encrypted) information such that every group member can update their view of the group and compute the new group key.

\paragraph{TreeKEM dynamics}

As already outlined briefly, TreeKEM uses a full binary tree to model the group and every user is associated with a leaf in the tree (though some leaves may have be left empty). Each user maintains a synchronized view of the tree, though different users will know more about different parts of the tree. The group key is derived from the root of the tree. Every node $n$ in the tree has an associated key pair $(pk_n, sk_n)$ output by $\Pi.\gen$ where $\Pi$ is a public-key encryption scheme. All public keys are known to all users. Let the \emph{direct path} of a leaf be the path from the leaf's parent to the root. Every user at a leaf knows the secret key of their leaf and, in the usual case, the secret keys of all nodes on their direct path, though we will see exceptions to this rule later. To illustrate the scheme and how commit operations are performed, we will consider of a group with users $A, B, \ldots, G$ and $H$, as depicted in Figure~\ref{fig:treekem-tree}. In the following, we will use these labels for the users both to refer to the users themselves and to their nodes in the tree.

\begin{figure}
	\begin{center}
		\includegraphics{figures/treekem-tree}
	\end{center}
	\caption{Illustration of a group with users 8 users in the TreeKEM protocol.}\label{fig:treekem-tree}
\end{figure}

\paragraph{Simple commits} \label{sec:simple-commit} The idea behind this tree structure is that it allows for a user creating a commit with a new group key to share the new group key with the group using only a few encryptions, while still updating all the secrets the user knew in the tree in order to recover from a possible compromise (recall that in a CGKA scheme a commit also updates the committer's key material).
To illustrate how a commit is performed and how the new group key is computed, say user $A$ performs a commit. First we only consider commits without any proposals. TreeKEM specifies two hash functions $\hgen, \hdep \colon \{0, 1\}^{\rho(\eta)} \to \{0, 1\}^{\rho(\eta)}$ where $\rho(\eta)$ gives the number of bits of randomness used by $\Pi.\gen(1^\eta)$. Let $d = 3$ the depth of user $A$. $A$ will replace all the $d + 1$ nodes on their path to the root (including their leaf) with new nodes $A, p_1, \ldots, p_d$. Although it would be more accurate to say that $A$ just replaces the information stored in the original nodes, and this view makes more sense when implementing the protocol, it will become convenient later to say that $A$ creates new nodes.
The key pairs for the new nodes are sampled as follows. For the leaf node $A$, user $A$ simply samples a key pair by running $\Pi.\gen(1^\eta)$. For the remaining nodes, they first sample $s_1 \from \{0, 1\}^{\rho(\eta)}$ and compute the key pair of the first parent $p_1$ as $\Pi.\gen(1^\eta, \hgen(s_1))$. For $i \in \{2, \ldots, d\}$ they then compute $s_i \coloneqq \hdep(s_{i - 1})$ and set the key pair of $p_i$ to be $\Pi.\gen(1^\eta, \hgen(s_i))$. The new group key is $k \coloneqq \hdep(s_{d})$.

User $A$ only needs to share (encryptions of) the seeds $s_i$ for the other users to update their view of the tree and compute the new group key:
\begin{itemize}
	\item To share the group key with user $B$, $A$ computes the ciphertext $c_1 \coloneqq \Pi.\enc_{pk_B}(s_1)$. $B$ can then compute the seed $s_1$, then use that to compute the seeds $s_2, \ldots, s_d$, the key pairs of all new nodes on their path to the root and the group key $k$.
	\item To share the new group key with users $C$ and $D$, $A$ computes the ciphertext $c_2 \coloneqq \Pi.\enc_{pk_X}(s_2)$, where $X$ is the parent of the nodes $C$ and $D$. Both $C$ and $D$ know the secret key $sk_X$ of their parent and can decrypt $c_2$.
	\item To share the new group key with users $E, F, G$ and $H$, $A$ computes the ciphertext $c_3 \coloneqq \Pi.\enc_{pk_Y}(s_3)$, where $Y$ is the right child of the root node. Again, all users under $Y$ know $sk_Y$ and can thus decrypt $c_3$.
\end{itemize}
The commit $c$ that $A$ shares with all users includes the ciphertexts $c_1, c_2$ and $c_3$ and the public keys of all new nodes. Figure~\ref{fig:treekem-simple-update} illustrates the commit performed by $A$.

\begin{figure}
	\begin{center}
		\includegraphics{figures/treekem-simple-update}
	\end{center}
	\caption{The commit by user $A$ described in the text. Dashed directed edges illustrate the fact that the target is related to the source via the hash function $\hdep$. The solid directed edges illustrate the fact that the seed of the target node is encrypted to the public key of the source node.}\label{fig:treekem-simple-update}
\end{figure}

The nodes $B, X$ and $Y$ form the \emph{copath} of $A$: the copath of a node $v$ consists of the sibling of each node on $v$'s path to the root, excluding the root itself. In the ideal case as above, a node performing a commit only has to compute one encryption for each node on its copath, i.e. logarithmically many encryptions in the total number of users.


The above concepts suffice to understand our main results. For a discussion of how proposals are incorporated into a commit, we refer the reader to Section~\ref{sec:treekem-overview-proposals} of the appendix.

\subsection{The GSD game} \label{sec:gsd-intro}

The Generalized Selective Decryption (GSD) security game \cite{gsd} was introduced precisely to analyze adaptive security for protocols based on a graph-like structure, as is the case with TreeKEM. It was initially defined for the private-key setting and later adapted to the public-key setting in \cite{ttkem}.

In the GSD security game, given an encryption scheme a graph, the \emph{GSD graph}, is constructed by the challenger where every node in the graph is associated with a symmetric key in the private-key setting, or a public/private key pair in the public-key setting. The adversary can then request encryptions of a node's (secret) key under the (public) key of another node. In the public-key setting, such an \emph{encryption query} also reveals the node's public key. This creates an \emph{encryption edge} in the graph, directed from the node whose (public) key was used for encryption to the node whose key was encrypted. The adversary can also corrupt any node, which reveals its (secret) key and allows the adversary to compute the (secret) key of any other node reachable from the corrupted node in the graph by performing decryptions along the path to the other node. At the end of the game the adversary chooses a node to be challenged on, the \emph{challenge node}. A coin is then tossed and the adversary is given either the (secret) key of the challenge node or a uniformly random (secret) key and it must guess which scenario it is in. The possible choices for the challenge node must of course be restricted to nodes whose keys were not compromised through a corruption, meaning that the challenge node should never be reachable from a corrupted node in the graph. Further restrictions are also necessary which we do not go into here. Figure~\ref{fig:gsd-example} illustrates what an example GSD graph may look like.

\begin{figure}
	\begin{center}
		\includegraphics{figures/gsd-example}
	\end{center}
	\caption{An illustration of the GSD graph for an instance of the GSD game. The challenge node is $v$. The node $c$ was corrupted, resulting in all nodes reachable from it being compromised, as marked with red color.} \label{fig:gsd-example}
\end{figure}

The graph constructed in the public-key GSD game and the tree structure behind the TreeKEM protocol clearly resemble each other. Let $\Pi$ the public-key encryption scheme in use, where $\Pi.\gen(1^\eta)$ samples $\rho(\eta)$ random bits. We can make some small modifications to the public-key GSD game such that the operations performed in TreeKEM match the ones performed in this modified GSD game. Take the functions $\hgen, \hdep$ used in TreeKEM and first modify the game as follows:
\begin{itemize}
	\item the key pair of a node $v$ is generated by sampling a seed $s_v \in \{0, 1\}^{\rho(\eta)}$ and computing $(pk_v, sk_v) = \Pi.\gen(1^\eta, \hgen(s_v))$
	\item encryption queries encrypt the seed of the target node instead of its secret key
\end{itemize}
Now the generation of key pairs and the encryptions computed in TreeKEM match what is done in this adapted GSD game. To model the fact that in TreeKEM the seed of a node may depend on the seed of another node through $\hdep$ (as in the new direct path computed in a commit), we can introduce a new type of edge which we call a \emph{seed dependency}: a seed dependency $(u, v)$ implies that $s_v = \hdep(s_u)$.

\subsection{Existing security proofs}

The work in \cite{ttkem} made use of the relationship between the (public-key) GSD game and TreeKEM described in the previous section. They proved a polynomial bound for the adaptive security of the public-key GSD game in the Random Oracle Model (ROM) \cite{rom} for an arbitrary IND-CPA secure public-key encryption scheme. The core idea behind their proof is simple. Intuitively, the only way for an adversary to learn about the seed of an uncorrupted node for the first time is through the encryption edges into it. The authors then show that in the ROM, one can reduce security in the GSD game to the IND-CPA security of the public-key encryption scheme. They apply standard guessing arguments and a clever, albeit complicated, hybrid argument to achieve a security loss in $\mathcal{O}(N^2)$, where $N$ is the number of nodes in the GSD graph. The $N^2$ loss stems from the fact that two nodes in the GSD graph need to be guessed correctly in order for the reduction succeed.

This result implies a polynomial bound for the security of TreeKEM as a CGKA scheme as outlined in \cite[Theorem 4]{ttkem} and subsequently proven in more detail in \cite[Theorem 12]{modular-group-messaging}, and was the first proof of adaptive security for TreeKEM.

\subsection{Contributions}

\paragraph{Tighter GSD security for DHIES} In this work, we formally prove the adaptive security of a specific public-key encryption scheme, the DHIES  scheme \cite{dhies}, in the adapted public-key GSD game described above, in the ROM. Focusing on the DHIES scheme allows us to achieve a tighter bound than the one in \cite{ttkem}. Each encryption of a seed $s_v$ with DHIES is a tuple of the form $\langle g^{x}, \Pi_s.\enc_{k}(s_v) \rangle$ with $k = \hdh(g^{x y})$, where $g$ is a generator in the Diffie-Hellman group, $\Pi_s$ is the private-key encryption scheme used in DHIES, $\hdh$ is a hash function and $y$ is the secret key of the source node of the encryption edge. By modelling $\hdh$ as a random oracle, we know that in order for an adversary to learn anything from this encryption, they must have either learned $k$ by querying $\hdh$ and then decrypted the ciphertext $c = \Pi_s.\enc_{k}(s_v)$, or they must have gleaned information from $c$ without knowing the key $k$. We can reduce the first case to the hardness of the Diffie-Hellman problem with a security loss of $\mathcal{O}(N)$. To achieve a linear loss, we first guess the node $v$ for which the Diffie-Hellman problem was solved on an outgoing encryption edge and exploit the self-reducability property of the Diffie-Hellman problem in order to embed a single Diffie-Hellman challenge into all outgoing edges. The second case can be reduced to the security of the private-key encryption scheme with a security loss of $\mathcal{O}(\delta \cdot N)$ where $\delta$ is the maximum in-degree in the GSD graph.
This follows from guessing the target node $s_v$ and then applying a standard hybrid argument to up to $\delta$ encryptions edges ending in $v$\footnote{The same hybrid argument does not work for directly reducing to the security of the public-key encryption scheme due to a technicality.}. In Section~\ref{sec:tighter-mis-eav-security} of the appendix we show the security loss can be reduced to $\mathcal{O}(N)$ for a very specific set of schemes.

Besides providing a tighter bound, our proof is more intuitive than the one in \cite{ttkem}. Our GSD definition also makes the proof notably simpler and lends itself much more nicely for relating it to the security of TreeKEM. A similar GSD defintion was already introduced in \cite{modular-group-messaging}, but the formulation there does not simplify the proof as in our work. See Section~\ref{sec:sd-gsd-game}.

\paragraph{The security of TreeKEM} Our final result for TreeKEM has security loss of $\mathcal{O}(c \cdot u^2)$ reducing to EAV security of the private-key encryption scheme and a loss of $\mathcal{O}(c \cdot u)$ reducing to hardness of the Diffie-Hellman problem, where $c$ is the number of commits and $u$ the number of users. The result in \cite{ttkem} implies a security loss of $\mathcal{O}((c \cdot u)^2)$ reducing to IND-CPA security of the private-key encryption scheme. Our result shows that TreeKEM has a x-bit security level with 128-bit parameters (under standard assumptions).

As far as we know, we are the first to evaluate the security level of TreeKEM guaranteed by our security proof.
