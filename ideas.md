- technically one could embed the DH challenge (g^x, g^y) at every node in the GSD graph: at node $u$, set $pk_u = g^x \cdot g^{a_u} = g^{x_u}$ with $a_u \from [|G|]$. Then from $g^{x_u \cdot y_i} = g^{(x + a_u) \cdot (y + b_i)} = g^{x \cdot y + x \cdot b_i + a_u \cdot y + b_i \cdot a_u}$ we can compute $g^{x \cdot y}$. Problem: After a corruption, the adversary can notice that running $Gen(H_{gen}(s_u))$ does not give $pk_u$ as the public key. We can't program the oracle since if we knew the random bits that result $pk_u$ being the public key, then we can run $Gen$ on those bits and learn the secret key and thus $x$.
- similarly, one can embed a seed $s$ at every node: for node $u$, set $s_u = s XOR r_u$. Then, whenever the adversary queries a seed $s'$, check if $s' XOR r_u = s$ for any $u$. If $s' = s_u$ for some $u$, then $s' XOR r_u = s$, so we can use this to detect whether $s$ got encrypted. We adapt the MI-EAV game such that the adversary can send a different pair of messages for each query. The hybrid argument proof works out just the same (although key-rerandomizability doesn't) and this allows the adversary to embed queries from the adversary at every encryption edge. Problem: After a corruption the adversary can see that the symmetric key for an encryption that was embedded does not match the symmetric key one gets from $H_{DH}(pk_u^y)$. We can't program $H_{DH}(pk_u^y)$, since we don't know the symmetric key that the challenger used (otherwise we could just decrypt the message and decide whether b = 0 or b = 1).
- do corruptions really help the adversary?
