\chapter{Introduction}

We all rely on messaging applications like WhatsApp, Facebook Messenger, Signal, etc.\ in our daily lives and take it for granted that our messages will be transmitted securely, for some definition of ``secure''. A common security feature expected from the protocol employed in a messaging application and known also to the general public is end-to-end encryption \todo{put emphasis?}, i.e. that only the end users of a messaging session can read the messages being sent and the service provider or any party with access to the communication channel is not able to do so. Another straightforward feature is that the protocol should work in an asynchronous setting: we would like to send messages even when to recipient is offline, and we expect them to receive the messsage once they come online. For this we must rely on a server to store and deliver the messages (without being able to read them).

There are two more advanced security features expected from messaging protocols today, both related to security in case a user is compromised:
\begin{itemize}
	\item forward secrecy (FS): the compromise should not reveal the contents of old messages
	\item post-compromise security (PCS): after the user recovers from the compromise, new messages are secure once again
\end{itemize}
As a user may well not know that they have been compromised, ensuring PCS requires regularly updating the key material used for encryption (in a way that the information leaked in a compromise \emph{before} the update does not suffice to compute encryption keys used \emph{after} the update). The more often the key material can be updated, the stronger the level of PCS that is achieved. Thus, updating the key material should be an efficient operation.

For messaging between two users, the Double Ratchet protocol \cite{double-ratchet}, the main component of the so-called Signal Protocol, is a widely adopted solution used by major messaging applications such as Signal, WhatsApp, Facebook Messenger and more. It is well studied and achieves all of the above security guarantees \cite{double-ratchet-analysis}. For messaging in a group of more than two users, a straightforward solution is to maintain 1:1 communication channels using the Double Ratchet protocol between every pair of users and send messages to the group by sending them to every member individually. This achieves the same level of security as a 1:1 channel \todo{true?}, but requires a number of encryption operations linear in the group size to send a message.

Another common solution is to use ``sender keys`` \cite{sender-keys}: every user creates a symmetric key, their \emph{sender key}, and distributes this sender key to every other user using 1:1 channels as before. A user sending a message then derives a symmetric encryption key for the message from their sender key, while continually updating their sender key (with each sent message) to provide FS. However, achieving PCS is costly: if a user is compromised, the sender keys of all users are leaked and recovering from the compromise requires each user to send a new sender key to every other user over the respective 1:1 channels, resulting in a number of operations linear in the group size per user and a quadratic number of operations in total. Moreover, dynamic group membership introduces additional complexity:
\begin{itemize}
	\item adding a new member involves the new member sharing their sender key with all other group members \question{How does the new member receive the sender keys? From an existing member?}
	\item removing a member requires distributing new sender keys in the group, just like recovering from a compromise
\end{itemize}
The Messaging Layer Security (MLS) protocol, recently standardized in \cite{rfc9420}, proposes a solution for group messaging with greater efficiency and the same strong security guarantees as for the two-party case. Updating key material and adding or removing member can be achieved with a logarithmic number of operations (although the complexity may still degrade to linear in certain scenarios). At the core of MLS is a fairly recent primitive called a \emph{continuous group key agreement} (CGKA) scheme \cite{rtreekem} (this primitive was introduced only \emph{after} the first draft of the MLS protocol). In essence, a CGKA scheme enables a group of users to agree on a \emph{group key}, which they can then use to derive symmetric message encryption keys. This key must be indistinguishable from a random key for anyone outside the group eavesdropping on all communication, while also achieving FS and PCS in the face of compromises. A CGKA scheme must however also provide mechanisms for members to update their key material (enabling PCS), adding new users to the group and removing members from the group. Moreover, the scheme must work in the asynchronous setting with an untrusted server to deliver protocol messages.

The CGKA scheme used in the MLS protocol is called TreeKEM (initially proposed in \cite{treekem}) and the majority of the literature on MLS is dedicated to analyzing TreeKEM or proposing better CGKA schemes \cite{ttkem,rtreekem,insider-security,modular-group-messaging,cocoa,decaf} \todo{how many papers does it make sense to cite here? the longer the list, the more papers I haven't actually read.}. The TreeKEM protocol has undergone multiple changes since its inception. In this work we refer to the version documented in RFC 9420. TreeKEM, as adopted from its predecessors, structures a group of users as a binary tree with the group key at the root and all group members as leaves. Group members may then compute the group key, update it or add/remove other members with a number of operations logarithmic in the group size.

Given that the vision for the MLS protocol is for it to become the new standard for messaging protocols and that it has support from several large companies \cite{google-mls,mls-support}, it has the potential to be used by a huge number of users. Thus, understanding the security of MLS and hence also of TreeKEM is of great importance. This means having formal security guarantees about the security provided by TreeKEM (based on appropriate hardness assumptions). The first important step in this direction was the conception of the CGKA primitive and the accompanying definitions of security introduced in different works (for example \cite{rtreekem, ttkem}). Such definitions clarify what kind of adversaries we can provide security against and thus what kind of security one should expect from the scheme when using it in practice. Moreover, proofs of (reasonably tight) security under these definitions show what level of security we should expect from the scheme and serve as a guide to implementors on what values to choose for the security parameter. Proofs also provide strong justification that there are no flaws in the overall design of the scheme.

One choice that can be made when defining the security of a CGKA scheme is whether the adversary is modeled as \emph{selective} or \emph{adaptive}. In the former case, the adversary must provide all the interactions it will have with the protocol and when it will attempt to break the scheme at the beginning of the security game, while in the latter case the adversary can make its decisions based on responses from previous interactions. Clearly, the adaptive setting is much closer to how an attack would unfold in practice, so it is desirable to prove security against adaptive adversaries. However, achieving this without too much of a blow-up in the security loss is a challenge since one often resorts to guessing actions performed by the adversary.

The Generalized Selective Decryption (GSD) security game \cite{gsd} was introduced precisely to analyze adaptive security for protocols based on a graph-like structure (as is the case with TreeKEM). It was initially defined for the private-key setting and later adapted to the public-key setting in \cite{ttkem}. The work in \cite{ttkem} proved a polynomial bound for the adaptive security of the public-key GSD game in the so-called Random Oracle Model (ROM) for an arbitrary IND-CPA secure public-key encryption scheme. This result implies a polynomial bound for the adaptive security of TreeKEM as a CGKA as outlined also in \cite[Theorem 4]{ttkem} and subsequently proved in more detail in \cite[Theorem 12]{modular-group-messaging}.

In this work, we prove a tighter bound for the adaptive security of a more general version of the public-key GSD game in the ROM for the DHIES scheme, which is currently the only scheme specified in the MLS cipher suite. Moreover, we provide our own reduction from the CGKA security of TreeKEM to the security of our GSD game.

\section{Technical overview}

\subsection{GSD}

Describe GSD

\subsection{TreeKEM}

Describe TreeKEM and operations

\section{Contributions}

\todo{describe results and contribution in more detail
	\begin{itemize}
		\item own GSD definition, similar to \cite{modular-group-messaging}
		\item complete and simple proofs
		\item tighter bound
		\item clearer security definitions for SD-GSD and CGKA
		\item more complete TreeKEM result
	\end{itemize}
}

Following the general approach used in \cite{ttkem} to prove the security of (a variant of) TreeKEM in the ROM, we first prove a result on the GSD security of an IND-CPA secure encryption scheme in Section~\vref{sec:tighter-gsd-security}. The  We do this specifically for the DHIES scheme, which is currently the only encryption scheme specified in the MLS RFC (\cite{rfc9420}), to achieve a better reduction loss. Moreover, we will make some notable modifications to the public-key GSD game defined in \cite{ttkem}, to allow for the result to be applied to TreeKEM more directly and thus simplify the security proof.
